# Effective Typescript

## 4장 타입 설계

### 아이템 28. 유효한 상태만 표현하는 타입을 지향하기

- 효과적으로 타입을 설계하려면, 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 가장 중요하다.

```typescript
interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}

function renderPage(state: State) {
  if (state.error) {
    return `Error! Unable to load ${currentPage}: ${state.error}`;
  } else if (state.isLoading) {
    return `Loading ${currentPage}...`;
  }
  return `<h1>${currentPage}</h1>\n${state.pageText}`;
}
```

- 위의 코드에서 분기 조건이 명확히 분리되어 있지 않다.
  - isLoading이 true이고 동시에 error 값이 존재하면 로딩 중인 상태인지 오류가 발생한 상태인지 명확히 구분할 수 없다.
    - 필요한 정보가 부족하기 때문이다.

```typescript
async function changePage(state: State, newPage: string) {
  state.isLoading = true;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const text = await response.text();
    state.isLoading = false;
    state.pageText = text;
  } catch (e) {
    state.error = '' + e;
  }
}
```

- 위 코드의 문제점
  - 오류가 발생했을 떄, state.isLoading을 false로 설정하는 로직이 빠져 있다.
  - state.error를 초기화하지 않았기 때문에, 페이지 전환 중에 로딩 메시지 대신 과거의 오류 메시지를 보여주게 된다.
  - 페이지 로딩 중에 사용자가 페이지를 바꿔 버리면 어떤 일이 벌어질지 예상하기 어렵다. 새 페이지에 오류가 뜨거나, 응답이 오는 순서에 따라 두 번째 페이지가 아닌 첫 번째 페이지로 전환될 수도 있다.

```typescript
interface RequestPending {
  state: 'pending';
}

interface RequestError {
  state: 'error';
  error: string;
}

interface RequestSuccess {
  state: 'ok';
  pageText: string;
}

type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  current: string;
  requests: { [page: string]: RequestState };
}
```

- 위의 코드는 상태를 나타내는 타입의 코드 길이가 서너 배 길어지긴 했지만, 무효한 상태를 허용하지 않도록 크게 개선되었다.

```typescript
function renderPage(state: State) {
  const { currentPage } = state;
  const requestState = state.requests[currentPage];
  switch (requestState.state) {
    case 'pending':
      return `Loading ${currentPage}...`;
    case 'error':
      return `Error! Unable to load ${currentPage}: ${state.error}`;
    case 'ok':
      return `<h1>${currentPage}</h1>\n${state.pageText}`;
  }
}

async function changePage(state: State, newPage: string) {
  state.requests[newPage] = { state: 'pending' };
  state.currentPage = newPage;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const pageText = await response.text();
    state.pageText[newPage] = { state: 'ok', pageText };
  } catch (e) {
    state.requests[newPage] = { state: 'error', error: '' + e };
  }
}
```

- 위의 코드에서 모호함은 완전히 사라졌다.
  - 현재 페이지가 무엇인지 명확하며, 모든 요청은 정확히 하나의 상태로 맞아 떨어진다.

#### 요약

- 유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 된다.
- 유효한 상태만 표현하는 타입을 지향해야 한다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고퉁을 줄일 수 있다.

### 아이템 29. 사용할 때는 너그럽게, 생성할 때는 엄격하게

- 함수의 매개변수는 범위가 넓어도 되지만, 결과를 반환할 때는 일반적으로 타입의 범위가 더 구체적이어야 한다.
- 유니온 타입의 요소별 분기를 위한 한 가지 방법은, 좌표를 위한 기본 형식을 구분하는 것이다.
  - 배열과 배열 같은 것(array-like)의 구분을 위해 자바스크립트의 관례에 따라 LngLat와 LngLatLike를 구분할 수 있다.

#### 요약

- 보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있다. 선택적 속성과 유니온 타입은 반환 타입보다 매개변수 타입에 더 일반적이다.
- 매개변수와 반환 타입의 재사용을 위해서 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)를 도입하는 것이 좋다.

### 아이템 30. 문서에 타입 정보를 쓰지 않기

```typescript
/**
 * 전경색(foreground) 문자열을 반환한다.
 * 0개 또는 1개의 매개변수를 받는다.
 * 매개변수가 없을 때는 표준 전경색을 반환한다.
 * 매개변수가 있을 때는 특정 페이지의 전경색을 반환한다.
 */
function getForegroundColor(page?: string) {
  return page === 'login' ? { r: 127, g: 127, b: 127 } : { r: 0, g: 0, b: 0 };
}
```

- 위 예시에서 코드와 주석의 정보가 맞지 않다.
- 코드와 주석이 맞지 않는다면 둘 다 잘못된 것이다.
- 코드가 제대로 반영되고 있다면, 주석에는 세 가지 문제점이 있다.
  - 함수가 string 형태의 색깔을 반환한다고 적혀 있지만 실제로는 {r, g, b} 객체를 반환한다.
  - 주석에는 함수가 0개 또는 1개의 매개변수를 받는다고 설명하고 있지만, 타입 시그니처만 보아도 명확하게 알 수 있는 정보이다.
  - 불필요하게 장황하다. 함수 선언과 구현체보다 주석이 더 길다.
- 함수의 입력과 출력의 타입을 코드로 표현하는 것이 주석보다 더 나은 방법이다.
- 값을 변경하지 않는다고 설명하거나, 매개변수를 변경하지 않는다는 주석보다는, readonly로 선언하여 타입스크립트가 규칙을 강제하도록 하는 것이 좋다.

#### 요약

- 주석과 변수명에 타입 정보를 적는 것은 피해야 한다. 타입 선언이 중복되는 것으로 끝나면 다행이지만 최악의 경우는 타입 정보에 모순이 발생하게 된다.
- 타입이 명확하지 않은 경우는 변수명에 단위 정보를 포함하는 것을 고려하는 것이 좋다.
