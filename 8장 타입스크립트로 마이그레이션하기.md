# Effective Typescript

## 8장 타입스크립트로 마이그레이션하기

### 아이템 58. 모던 자바스크립트로 작성

- 타입스크립트 컴파일러는 자바스크립트 트랜스파일러로 사용할 수 있다.
- 타입스크립트는 자바스크립트의 상위집합이기 때문에, 코드를 최신 버전으로 바꾸다 보면 타입스크립트의 일부를 저절로 익힐 수 있다.

#### ECMAScript 모듈 사용하기

- ES2015부터는 import와 export를 사용하는 ECMAScript 모듈이 표준이 되었다.
- 마이그레이션 대상인 자바스크립트 코드가 단일 파일이거나 비표준 모듈 시스템을 사용 중이라면 ES 모듈로 전환하는 것이 좋다.

#### 프로토타입 대신 클래스 사용하기

- 마이그레이션하려는 코드에서 단순한 객체를 다룰 때 프로토타입을 사용하고 있었다면 클래스로 바꾸는 것이 좋다.
- 프로토타입으로 구현한 객체보다 클래스로 구현한 객체가 문법이 간결하고 직관적이다.

#### var 대신 let/const 사용하기

- 스코프, 호이스팅 문제로 let, const를 사용하는 것이 좋다.

#### for(;;) 대신 for-of 또는 배열 메서드 사용하기

- for-of 루프는 코드가 짧고 인덱스 변수를 사용하지 않기 때문에 실수를 줄일 수 있다.
- 인덱스 변수가 필요한 경우엔 forEach 메서드를 사용하면 된다.

#### 함수 표현식보다 화살표 함수 사용하기

- this 키워드는 일반적인 변수들과는 다른 스코프 규칙을 가진다.
- 화살표 함수를 사용하면 상위 스코프의 this를 유지할 수 있다.
- 인라인에서는 일반 함수보다 화살표 함수가 더 직관적이며 코드도 간결해진다.
- 컴파일러 옵션에 noImplicitThis를(또는 strict) 설정하면, 타입스크립트가 this 바인딩 관련된 오류를 표시해 주므로 설정하는 것이 좋다.

#### 단축 객체 표현과 구조 분해 할당 사용하기

```typescript
// bad
const x = 1;
const y = 2;
const z = 3;

const pt = {
  x: x,
  y: y,
  z: z,
};

// good
const x = 1,
  y = 2,
  z = 3;
const pt = { x, y, z };
```

- 화살표 함수 내에서 객체르르 반환할 때 소괄호로 감싸야 한다.

```typescript
const obj = {
  props: {
    a: 1,
    b: 2,
  },
};

// bad
const props = obj.props;
const a = props.a;
const b = props.b;

// good
const { props } = obj;
const { a, b } = props;

const point = [1, 2, 3];
const [x, y, z] = point;
const [, a, b] = point; // 첫 번째 요소 무시
```

#### 함수 매개변수 기본값 사용하기

- 자바스크립트에서 함수의 모든 매개변수는 선택적이며, 매개변수를 지정하지 않으면 undefined로 간주된다.
- 모던 자바스크립트에서 매개변수에 기본값을 직접 지정할 수 있다.

#### 저수준 프로미스나 콜백 대신 async/await 사용하기

- async와 await를 사용하면 코드가 간결해져서 버그나 실수를 방지할 수 있고, 비동기 코드에 타입 정보가 전달되어 타입 추론을 가능하게 한다.

#### 연관 배열에 객체 대신 Map과 Set 사용하기

#### 타입스크립트에 use strict 넣지 않기

- 타입스크립트에서 수행되는 안전성 검사가 엄격 모드보다 훨씬 더 엄격한 체크를 하기 때문에, 타입스크립트 코드에서 use strict는 무의미하다.
  - 실제로 타입스크립트 컴파일러가 생성하는 자바스크립트 코드에서 `use strict`가 추가 된다.

#### 요약

- 타입스크립트 개발 환경은 모던 자바스크립트도 실행할 수 있으므로 모던 자바스크립트의 최신 기능들을 적극적으로 사용해야 한다. 코드 품질을 향상시킬 수 있고, 타입스크립트의 타입 추론도 나아진다.
- 타입스크립트 개발 환경에서는 컴파일러와 언어 서비스를 통해 클래스, 구조 분해, async/await 같은 기능을 쉽게 배울 수 있다.
- `use strict`는 타입스크립트 컴파일러 수준에서 사용되므로 코드에서 제거해야 한다.
- TC39의 깃헙 저장소와 타입스크립트의 릴리스 노트를 통해 최신 기능을 확인할 수 있다.

### 아이템 59. 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기

- @ts-check를 사용하면 타입스크립트 전환시에 어떤 문제가 발생하는지 미리 시험해 볼 수 있다.
  - 매우 느슨한 수준으로 타입 체크를 수행하는데, noImplicitAny 설정을 해제한 것보다 헐거운 체크를 수행한다.

#### 선언되지 않은 전역 변수

- 숨어 있는 변수는, 변수를 제대로 인식할 수 있게 별도로 타입 선언 파일을 만들어야 한다.

#### 알 수 없는 라이브러리

- @ts-check를 사용하면 타입스크립트로 마이그레이션하기 전에 서드파티 라이브러리들의 타입 선언을 활용하여 타입 체크를 시험해 볼 수 있다.

#### DOM 문제

- 웹 브라우저에서 동작하는 코드라면, 타입스크립트는 DOM 엘리먼트 관련된 부분에 수많은 오류를 표시하게 된다.

#### 부정확한 JSDoc

- 프로젝트에서 JSDoc 스타일의 주석을 사용 중이었다면, @ts-check 지시자를 설정하는 순간부터 기존 주석에 타입 체크가 동작하게 되고 갑자기 수많은 오류가 발생하게 된다.
  - 타입 정보를 추가해 나가야 한다.

#### 요약

- 파일 상단에 `// @ts-check`를 추가하면 자바스크립트에서도 타입 체크를 수행할 수 있다.
- 전역 선언과 서드파티 라이브러리의 타입 선언을 추가하는 방법을 익혀야 한다.
- JSDoc 주석을 잘 활용하면 자바스크립트 상태에서도 타입 단언과 타입 추론을 할 수 있다.
- JSDoc 주석은 중간 단계이기 때문에 너무 공들일 필요는 없다. 최종 목표는 .ts로 된 타입스크립트 코드임을 명심한다.

### 아이템 60. allowJs로 타입스크립트와 자바스크립트 같이 사용하기

- 대규모 프로젝트의 경우 한꺼번에 작업하는 것이 불가능하므로 점진적으로 전환할 수 있어야 한다.
  - 마이그레이션 기간 중에 자바스크립트와 타입스크립트가 동시에 동작할 수 있어야 한다.
- 타입스크립트와 자바스크립트가 공존하는 방법의 핵심은 allowJs 컴파일러 옵션인데, 타입스크립트 파일과 자바스크립트 파일을 서로 임포트할 수 있게 해준다.
- 번들러에 타입스크립트가 통합되어 있거나, 플러그인 방식으로 통합이 가능하다면 allowJs를 간단히 적용할 수 있다.

#### 요약

- 점진적으로 마이그레이션을 위해 자바스크립트와 타입스크립트를 동시에 사용할 수 있게 allowJs 컴파일러 옵션을 사용한다.
- 대규모 마이그레이션 작업을 시작하기 전에, 테스트와 빌드 체인에 타입스크립트를 적용해야 한다.

### 아이템 61. 의존성 관계에 따라 모듈 단위로 전환하기

- 점진적 마이그레이션을 할 때는 모듈 단위로 하는 것이 이상적이다.
  - 그런데 한 모듈을 골라서 타입 정보를 추가하면, 해당 모듈이 의존하는 모듈에서 비롯되는 타입 오류가 발생된다.

1. 프로젝트 내에 존재하는 모듈은 서드파티 라이브러리에 의존하지만 서드파티 라이브러리는 해당 모듈에 의존하지 않기 때문에, 서드파티 라이브러리 타입 정보를 먼저 해결해야 한다.
2. 외부 API를 호출하는 경우도 있기 때문에 외부 API의 타입 정보도 추가해야 한다.
3. 모듈 단위로 마이그레이션을 시작하기 전에, 모듈 간의 의존성 관계를 시각화하면 도움이 된다.
4. 마이그레이션할 때는 타입 정보 추가만 하고, 리팩터링을 해서는 안된다.

#### 선언되지 않은 클래스 멤버

- 자바스크립트에서는 클래스 멤버 변수를 선언할 필요가 없지만, 타입스크립트에서는 명시적으로 선언해야 한다.

#### 타입이 바뀌는 값

- 자바스크립트에서는 상관 없으나, 타입스크립트에서는 오류가 발생한다.
  - 한꺼번에 객체를 생성하면 간단히 오류를 해결할 수 있다.
- 자바스크립트 상태에서 JSDoc과 @ts-check를 사용해 타입 정보를 추가한 상태라면, 타입스크립트로 전환하는 순간 타입 정보가 무효화된다.

#### 요약

- 마이그레이션의 첫 단계는, 서드파티 모듈과 외부 API 호출에 대한 @types를 추가하는 것이다.
- 의존성 관계도의 아래에서부터 위로 올라가며 마이그레이션응 하면 된다. 첫 번째 모듈은 보통 유틸리티 모듈이다. 의존성 관계도를 시각화하여 진행 과정을 추적하는 것이 좋다.
- 이상한 설계를 발견하더라도 리팩터링을 하면 안된다. 마이그레이션 작업은 타입스크립트 전환에 집중해야 하며, 나중의 리팩터링을 위해 목록을 만들어 두는 것이 좋다.
- 타입스크립트로 전환하며 발견하게 되는 일반적인 오류들을 놓치지 않아야 한다. 타입 정보를 유지하기 위해 필요에 따라 JSDoc 주석을 활용해야 할 수도 있다.

### 아이템 62. 마이그레이션의 완성을 noImplicitAny 설정하기

- 처음에는 noImplicitAny를 로컬에만 설정하고 작업하는 것이 좋다.
  - 원격에서는 설정에 변화가 없기 때문에 빌드가 실패하지 않기 때문이다.
- noImplicitAny는 상당히 엄격한 설정이며, strictNullChecks 같은 설정을 적용하지 않더라도 대부분의 타입 체크를 적용한 것으로 볼 수 있다.

#### 요약

- noImplicitAny 설정을 활성화하여 마이그레이션의 마지막 단계를 진행해야 한다. noImplicitAny 설정이 없다면 타입 선언과 관련된 실제 오류가 드러나지 않다.
- noImplicitAny를 전면 적용하기 전에 로컬에서부터 타입 오류를 점진적으로 수정해야 한다. 엄격한 타입 체크를 적용하기 전에 팀원들이 타입스크립트에 익숙해질 수 있도록 시간을 준다.
