# Effective Typescript

## 2장 타입스크립트의 타입 시스템

### 아이템 6. 편집기를 사용하여 타입 시스템 탐색하기

#### 요약

- 편집기에서 타입스크립트 언어 서비스를 적극 활용해야 한다.
- 편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.
- 타입스크립트가 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 터득해야 한다.

### 아이템 7. 타입이 값들의 집합이라고 생각하기

- 타입은 할당 가능한 값들의 집합이다.
  - 집합은 범위라고 부르기도 한다.
- 가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, 타입스크립트에서는 never 타입이다.
- 다음으로 작은 집합은 한 가지 값만 포함하는 타입이다.
  - 유닛 타입이라고 불리는 리터털이다,
- 두 개 혹은 세 개를 묶으려면 유니온 타입을 사용한다.

```typescript
const x: never = 12; // 12 형식은 never 형식에 할당할 수 없습니다

type A = 'A';
type B = 'B';

type AB = 'A' | 'B';
const a: AB = 'A'; // 정상
const c: AB = 'C'; // 'C' 형식은 AB 형식에 할당할 수 없습니다
```

- 구조적 타이핑 규칙들은 어떠한 값이 다른 속성도 가질 수 있음을 의미한다.

```typescript
interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death: Date;
}

type PersonSpan = Person & Lifespan; // 교집합

const ps: PersonSpan = {
  name: 'Alan Turing',
  birth: new Date('1912/06/23'),
  death: new Date('1954/06/07'),
}; // 정상, 공집합 x
```

- 타입 연산자는 인터페이스의 속성이 아닌, 값의 집합에 적용된다.

```typescript
interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth: Date;
  death: Date;
}
```

- 타입이 집합이라는 관점에서 extends의 의미는 '~에 할당 가능한'과 비슷하게 '~의 부분 집합'이라는 의미로 받아들일 수 있다.
- extends 키워드는 제너릭 타입에서 한정자로도 쓰이며, '~의 부분 집합'을 의미하기도 한다.

| 타입스크립트 용어           | 집합 용어                    |
| :-------------------------- | :--------------------------- | ------------------------- |
| never                       | 공집합                       |
| 리터럴 타입                 | 원소가 1개인 집합            |
| 값이 T에 할당 가능          | 값 ∈ T(값이 T의 원소)        |
| T1이 T2에 할당 가능         | T1 ⊆ T2(T1이 T2의 부분 집합) |
| T1이 T2에 상속              | T1 ⊆ T2(T1이 T2의 부분 집합) |
| T1                          | T2(T1과 T2의 유니온)         | T1 ∪ T2(T1과 T2의 합집합) |
| T1 & T2(T1과 T2의 인터섹션) | T1 ∩ T2(T1과 T2의 교집합)    |
| unknown                     | 전체(universal) 집합         |

#### 요약

- 타입을 값의 집합으로 생각하면 이해하기 편하다. 이 집합은 유한(boolean 또는 리터럴 타입)하거나 무한(number 또는 string)하다.
- 타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합으로 표현된다. 두 타입은 서로 서브 타입이 아니면서도 겹쳐질 수 있다.
- 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.
- 타입 연산은 집합의 범위에 적용된다. A와 B의 인터섹션은 A의 범위와 B의 범위의 인터섹션이다. 객체 타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미한다.
- A는 B를 상속, A는 B에 할당 가능, A는 B의 서브 타입은 A는 B의 부분 집합과 같은 의미다.

### 아이템 8. 타입 공간과 값 공간의 심벌 구분하기

- 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.

```typescript
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({radius, height});
```

- 위의 예시에서 Cylinder는 타입 또는 값으로 쓰이며 서로 아무 관련도 없다.
  - 상황에 따라서 타입 또는 값으로 쓰일 수 있기 때문에 가끔 오류를 야기한다.
  - 심벌이 타입인지 값인지는 문맥을 살펴 알아내야 한다.
- 타입스크립트 코드에서 타입과 값은 번갈아 나올 수 있다.
- 타입 선언(:) 또는 단언문(as) 다음에 나오는 심벌은 타입인 반면, = 다음에 나오는 모든 것은 값이다.
- class와 enum은 상황에 따라 타입과 값 두 가지 모두 가능한 예약어다.
- 클래스가 타입으로 쓰일 때는 형태(속성과 메서드)가 사용되는 반면, 값으로 쓰일 떄는 생성자가 사용된다.
- 타입의 관점에서 typeof는 값을 읽어서 타입스크립트 타입을 반환한다.
- 값의 관점에서 typeof는 자바스크립트 런타임의 typeof 연산자가 된다.

```typescript
// Cylinder가 클래스일 때
const v = typeof Cylinder; // 값이 function
type T = typeof Cylinder; // 타입이 typeof Cylinder
```

- class는 값과 타입과 두 가지로 사용되며, 따라서 클래스에 대한 typeof는 상황에 따라 다르게 동작한다.
- 두 공간 사이에서 다른 의미를 가지는 코드 패턴
  - 값으로 쓰이는 this는 자바스크립트의 this 키워드이다. 타입으로 쓰이는 this는 `다형성 this`라고 불리는, this의 타입스크립트 타입이다. 서브 클래스의 메서드 체인을 구현할 때 유용하다.
  - 값에서 &와 |는 AND와 OR 비트연산이다. 타입에서는 인터섹션과 유니온이다.
  - const는 새 변수를 선언하지만, as count는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꾼다.
  - extends는 서브클래스(class A extends B) 또는 서브타입(interface A extends B) 또는 제너릭 타입의 한정자(Generic<T extends number>)를 정의할 수 있다.
  - in은 루프 또는 매핑된 타입에 등장하다.

#### 요약

- 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야 한다. 타입스크립트 플레이그라운드를 활용해 개념을 잡는 것이 좋다.
- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다. type과 interface 같은 키워드는 타입 공간에만 존재한다.
- class나 enum 같은 키워드는 타입과 값 두 가지로 사용될 수 있다.
- "foo"는 문자열 리터럴이거나 문자열 리터럴 타입일 수 있다. 차이점을 알고 구별하는 방법을 터득해야 한다.
- typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

### 아이템 9. 타입 단언보다는 타입 선언을 사용하기

```typescript
interface Person {
  name: string;
}

const alice: Person = { name: 'Alice' }; // 타입 선언
const bob = { name: 'bob' } as Person; // 타입 단언
```

```typescript
const alice: Person = {}; // error
const bob = {} as Person;
```

- 타입 단언은 강제로 타입을 지정했으니 타입 체커에게 오류를 무시하라고 하는 것이다.
- 접미사로 쓰이는 !는 그 값이 null이 아니라는 단언문으로 해석된다.

#### 요약

- 타입 단언보다 타입 선언을 사용해야 한다.
- 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 한다.
- 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문과 null 아님 단언문을 사용하면 된다.

### 아이템 10. 객체 래퍼 타입 피하기

- 자바스크립트에는 객체 이외에도 기본형 값들에 대한 일곱 가지 타입이 있다.
  - string, number, boolean, null, undefined, symbol, bigint
- 기본형들은 불변(immutable)이며 메서드를 가지지 않는다.
  - string의 경우 메서드를 가지고 있는 것처럼 보이지만, 자바스크립트는 기본형을 String 객체로 래핑하고 메서드를 호출하고 마지막에 래핑한 객체를 버린다.
- 어떠한 속성을 기본형에 할당하면 그 속성이 사라진다.

#### 요약

- 기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야 한다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 한다.
- 타입스크립트에서 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야 한다. String 대신 string, Number 대신 number를 사용해야 한다.

### 아이템 11. 잉여 속성 체크의 한계 인지하기

```typescript
interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}

const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present' // error
}

const obj = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: 'present' // error
}
const r: Room = obj; // 정상
```

- 위의 예시에서 첫번째는 구조적 타입 시스템에서 발생할 수 있는 중요한 종류의 오류를 잡을 수 있도록 잉여 속성 체크라는 과정이 수행되었다.
  - 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이다.
- 잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않는다.
  - 엄격한 객체 리터럴 체크라고도 불린다.
- 잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름의 오타 같은 실수를 잡는데 효과적이다.

#### 요약

- 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다.
- 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다르다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있다.
- 잉여 속성 체크에는 한계가 있다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.

### 아이템 12. 함수 표현식에 타입 적용하기

- 타입스크립트에서는 함수 표현식을 사용하는 것이 좋다.
  - 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다.

```typescript
type DiceRollFn = (sides: number) => number;
const rollDice: DiceRollFn = sides => { /* ... */ };
```

- 함수 타입의 선언은 불필요한 코드의 반복을 줄인다.

#### 요약

- 매개변수나 반환 값에 타입을 명시하기보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋다.
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보도록 한다. 라이브러리를 직접 만든다면 공통 콜백에 타입을 제공해야 한다.
- 다른 함수의 시그니처를 참조하려면 typeof fn을 사용하면 된다.

### 아이템 13. 타입과 인터페이스의 차이점 알기

```typescript
type TState = {
  name: string;
  capital: string;
}

interface IState {
  name: string;
  capital: string;
}
```

- 명명된 타입은 인터페이스로 정의하든 타입으로 정의하든 상태에 차이가 없다.
  - 추가 속성과 함께 할당한다면 동일한 오류가 발생한다.

```typescript
type TDict = { [key: string]: string };
interface IDict {
  [key: string]: string;
}
```

- 인덱스 시그니처는 인터페이스와 타입에서 모두 사용할 수 있다.

```typescript
type TFn = (x: number) => string;
interface IFn {
  (x: number): stirng;
}
```

- 함수 타입도 인터페이스나 타입으로 정의할 수 있다.
- 타입 별칭과 인터페이스는 모두 제너릭이 가능하다.
- 인터페이스는 타입을 확장할 수 있으며, 타입은 인터페이스를 확장할 수 있다.
- 클래스를 구현(implements)할 떄는, 타입과 인터페이스 둘 다 사용할 수 있다.

```typescript
type AorB = 'a' | 'b';
```

- 인터페이스는 타입을 확장할 수 있지만, 유니온은 할 수 없다.
- type 키워드는 일반적으로 interface보다 쓰임새가 많다.
  - type 키워드는 유니온이 될 수도 있고, 매핑된 타입 또는 조건부 타입 같은 고급 기능에 활용되기도 한다.
- 튜플과 배열 타입도 type 키워드로 간결하게 표현할 수 있다.
  - 인터페이스도 비슷하게 구현할 수 있으나 내장 메서드를 사용할 수 없다.

```typescript
interface IState {
  name: string;
  capital: string;
}
interface IState {
  population: number;
}

const wyoming: IState = {
  name: 'Wyoming',
  capital:  'Cheyenne',
  population: 500_000
};
```

- 위의 예시처럼 인터페이스는 보강(augment)이 가능하다.
  - 속성을 확장하는 것은 선언 병합(declaration merging)이라고 한다.
- 복잡한 타입이라면 타입 별칭을 사용하고, 간단한 객체 타입이라면 일관성과 보강을 고려하여 선택한다.

#### 요약

- 타입과 인터페이스의 차이점과 비슷한 점을 이해해야 한다.
- 한 타입을 type과 interface 두 가지 문법을 사용해서 작성하는 방법을 터득해야 한다.
- 프로젝트에서 어떤 문법을 사용할지 결정할 때 한 가지 일관된 스타일을 확립하고, 보강 기법이 필요한지 고려해야 한다.

### 아이템 14. 타입 연산과 제너릭 사용으로 반복 줄이기

- 타입 중복은 코드 중복만큼 많은 문제를 발생시킨다.
- 반복을 줄이는 가장 간단한 방법은 타입에 이름을 붙이는 것이다.
- 다른 방법은 한 인터페이스가 다른 인터페이스를 확장하게 해서 반복을 제거할 수 있다.

```typescript
interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}

type TopNavState = {
  [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k]
}
```

- TopNavState를 확장하여 State를 구성하기보다, State의 부분 집합으로 TopNavState를 정의하는 것이 좋고, State를 인덱싱하여 속성의 타입에서 중복을 제거할 수 있다.

```typescript
type Pict<T, K> = { [k in K]: T[k] };
```

- 매핑된 타입은 배열의 필드를 루프 도는 것과 같은 방식이며, Pick이라고 한다.

```typescript
type TopNavState = Pick<State, 'userId' | 'pageTitle' | 'recentFiles'>
```

```typescript
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}

interface OptionsUpdate {
  width?: number;
  height?: number;
  color?: string;
  label?: string;
}

class UIWidget {
  constructor(init: Options) { /* ... */ }
  update(options: OptionsUpdate) { /* ... */ }
}
```

- 위의 예시는 생성하고 난 다음에 업데이트가 되는 클래스이다.
  - update 메서드는 생성자와 동일한 매개변수이면서, 타입 대부분이 선택적 필드가 된다.

```typescript
type OptionsUpdate = { [k in keyof Options]?: Options[k] };
```

- 매핑된 타입과 keyof를 사용하면 Options으로부터 OptionsUpdate를 만들 수 있다.
- 이러한 패턴도 일반적이며, 표준 라이브러리에 Partial이라는 이름으로 있다.
- 값으로부터 타입을 만들어 낼 때는 선언의 순서에 주의해야 한다.
  - 타입 정의를 먼저 하고 값이 그 타입에 할당 가능하다고 선언하는 것이 좋다.
- 함수나 메서드의 반환 값에 명명된 타입을 만들 때, ReturnType 제너릭을 사용한다.
- 제너릭 타입에서 매개변수를 제한할 수 있는 방법은 extends를 사용하는 것이다.

#### 요약

- DRY 원칙을 타입에도 최대한 적용해야 한다.
- 타입에 이름을 붙여서 반복을 피해야 한다. extends를 사용해서 인터페이스 필드의 반복을 피해야 한다.
- 타입들 간의 매핑을 위해 타입스크립트가 제공한 도구들을 공부하면 좋다. 여기에는 keyof, typeof, 인덱싱, 매핑된 타입들이 포함된다.
- 제너릭 타입은 타입을 위한 함수와 같다. 타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑을 하는 것이 좋다. 제너릭 타입을 제한하려면 extends를 사용하면 된다.
- 표준 라이브러리에 정의된 Pick, Partial, ReturnType 같은 제너릭 타입에 익숙해져야 한다.

### 아이템 15. 동적 데이터에 인덱스 시그니처를 사용하기

- 자바스크립트 객체는 문자열 키를 타입의 값에 관계없이 매핑한다.
- 타입스크립트에서는 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현할 수 있다.

```typescript
type Rocket = { [property: string]: string };
const rocket: Rocket = {
  name: 'Falcon 9',
  variant: 'v1.0',
  thrust: '4,940 kN',
};
```

- [property: string]: string이 인덱스 시그니처이며, 다음 세 가지 의미를 담고 있다.
  - 키의 이름: 키의 위치만 표시하는 용도다. 타입 체커에서는 사용하지 않는다.
  - 키의 타입: string이나 number 또는 symbol의 조합이어야 하지만, 보통은 string을 사용한다.
  - 값의 타입: 어떤 것이든 될 수 있다.
- 이렇게 타입 체크가 수행되면 네 가지 단점이 드러난다.
  - 잘못된 키를 포함해 모든 키를 허용한다. name 대신 Name으로 작성해도 유효한 Rocket 타입이 된다.
  - 특정 키가 필요하지 않는다. {}도 유효한 Rocket 타입이다.
  - 키마다 다른 타입을 가질 수 없다. 예를 들어, thrust는 string이 아니라 number여야 할 수도 있다.
  - 타입스크립트 언어 서비스는 다음과 같은 경우에 도움이 되지 못한다. name:을 입력할 때, 키는 무엇이든 가능하기 때문에 자동 완성 기능이 동작하지 않는다.

#### 요약

- 런타임 때까지 객체의 속성을 알 수 없을 경우에만 인덱스 시그니처를 사용하도록 한다.
- 안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는 것을 고려해야 한다.
- 가능하다면 인터페이스, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋다.
