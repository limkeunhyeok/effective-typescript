# Effective Typescript

## 2장 타입스크립트의 타입 시스템

### 아이템 6. 편집기를 사용하여 타입 시스템 탐색하기

#### 요약

- 편집기에서 타입스크립트 언어 서비스를 적극 활용해야 한다.
- 편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.
- 타입스크립트가 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 터득해야 한다.

### 아이템 7. 타입이 값들의 집합이라고 생각하기

- 타입은 할당 가능한 값들의 집합이다.
  - 집합은 범위라고 부르기도 한다.
- 가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, 타입스크립트에서는 never 타입이다.
- 다음으로 작은 집합은 한 가지 값만 포함하는 타입이다.
  - 유닛 타입이라고 불리는 리터털이다,
- 두 개 혹은 세 개를 묶으려면 유니온 타입을 사용한다.

```typescript
const x: never = 12; // 12 형식은 never 형식에 할당할 수 없습니다

type A = 'A';
type B = 'B';

type AB = 'A' | 'B';
const a: AB = 'A'; // 정상
const c: AB = 'C'; // 'C' 형식은 AB 형식에 할당할 수 없습니다
```

- 구조적 타이핑 규칙들은 어떠한 값이 다른 속성도 가질 수 있음을 의미한다.

```typescript
interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death: Date;
}

type PersonSpan = Person & Lifespan; // 교집합

const ps: PersonSpan = {
  name: 'Alan Turing',
  birth: new Date('1912/06/23'),
  death: new Date('1954/06/07'),
}; // 정상, 공집합 x
```

- 타입 연산자는 인터페이스의 속성이 아닌, 값의 집합에 적용된다.

```typescript
interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth: Date;
  death: Date;
}
```

- 타입이 집합이라는 관점에서 extends의 의미는 '~에 할당 가능한'과 비슷하게 '~의 부분 집합'이라는 의미로 받아들일 수 있다.
- extends 키워드는 제너릭 타입에서 한정자로도 쓰이며, '~의 부분 집합'을 의미하기도 한다.

| 타입스크립트 용어           | 집합 용어                    |
| :-------------------------- | :--------------------------- | ------------------------- |
| never                       | 공집합                       |
| 리터럴 타입                 | 원소가 1개인 집합            |
| 값이 T에 할당 가능          | 값 ∈ T(값이 T의 원소)        |
| T1이 T2에 할당 가능         | T1 ⊆ T2(T1이 T2의 부분 집합) |
| T1이 T2에 상속              | T1 ⊆ T2(T1이 T2의 부분 집합) |
| T1                          | T2(T1과 T2의 유니온)         | T1 ∪ T2(T1과 T2의 합집합) |
| T1 & T2(T1과 T2의 인터섹션) | T1 ∩ T2(T1과 T2의 교집합)    |
| unknown                     | 전체(universal) 집합         |

#### 요약

- 타입을 값의 집합으로 생각하면 이해하기 편하다. 이 집합은 유한(boolean 또는 리터럴 타입)하거나 무한(number 또는 string)하다.
- 타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합으로 표현된다. 두 타입은 서로 서브 타입이 아니면서도 겹쳐질 수 있다.
- 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.
- 타입 연산은 집합의 범위에 적용된다. A와 B의 인터섹션은 A의 범위와 B의 범위의 인터섹션이다. 객체 타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미한다.
- A는 B를 상속, A는 B에 할당 가능, A는 B의 서브 타입은 A는 B의 부분 집합과 같은 의미다.

### 아이템 8. 타입 공간과 값 공간의 심벌 구분하기

- 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.

```typescript
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height: number) => ({radius, height});
```

- 위의 예시에서 Cylinder는 타입 또는 값으로 쓰이며 서로 아무 관련도 없다.
  - 상황에 따라서 타입 또는 값으로 쓰일 수 있기 때문에 가끔 오류를 야기한다.
  - 심벌이 타입인지 값인지는 문맥을 살펴 알아내야 한다.
- 타입스크립트 코드에서 타입과 값은 번갈아 나올 수 있다.
- 타입 선언(:) 또는 단언문(as) 다음에 나오는 심벌은 타입인 반면, = 다음에 나오는 모든 것은 값이다.
- class와 enum은 상황에 따라 타입과 값 두 가지 모두 가능한 예약어다.
- 클래스가 타입으로 쓰일 때는 형태(속성과 메서드)가 사용되는 반면, 값으로 쓰일 떄는 생성자가 사용된다.
- 타입의 관점에서 typeof는 값을 읽어서 타입스크립트 타입을 반환한다.
- 값의 관점에서 typeof는 자바스크립트 런타임의 typeof 연산자가 된다.

```typescript
// Cylinder가 클래스일 때
const v = typeof Cylinder; // 값이 function
type T = typeof Cylinder; // 타입이 typeof Cylinder
```

- class는 값과 타입과 두 가지로 사용되며, 따라서 클래스에 대한 typeof는 상황에 따라 다르게 동작한다.
- 두 공간 사이에서 다른 의미를 가지는 코드 패턴
  - 값으로 쓰이는 this는 자바스크립트의 this 키워드이다. 타입으로 쓰이는 this는 `다형성 this`라고 불리는, this의 타입스크립트 타입이다. 서브 클래스의 메서드 체인을 구현할 때 유용하다.
  - 값에서 &와 |는 AND와 OR 비트연산이다. 타입에서는 인터섹션과 유니온이다.
  - const는 새 변수를 선언하지만, as count는 리터럴 또는 리터럴 표현식의 추론된 타입을 바꾼다.
  - extends는 서브클래스(class A extends B) 또는 서브타입(interface A extends B) 또는 제너릭 타입의 한정자(Generic<T extends number>)를 정의할 수 있다.
  - in은 루프 또는 매핑된 타입에 등장하다.

#### 요약

- 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야 한다. 타입스크립트 플레이그라운드를 활용해 개념을 잡는 것이 좋다.
- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다. type과 interface 같은 키워드는 타입 공간에만 존재한다.
- class나 enum 같은 키워드는 타입과 값 두 가지로 사용될 수 있다.
- "foo"는 문자열 리터럴이거나 문자열 리터럴 타입일 수 있다. 차이점을 알고 구별하는 방법을 터득해야 한다.
- typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.
