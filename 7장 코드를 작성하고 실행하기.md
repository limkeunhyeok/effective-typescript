# Effective Typescript

## 7장 코드를 작성하고 실행하기

### 아이템 53. 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

- 타입스크립트 초기 버전에는 독립적으로 개발한 클래스, 열거형 모듈 시스템을 포함시켰다.
  - 새로 ECMAScript에서 부족했던 점을 내장 기능으로 추가했고, 타입스크립트 초기 버전과 호환성 문제가 발생했다.
    - 타입스크립트 팀은 자바스크립트 신규 기능을 채택하고, 초기 버전과 호환성을 포기했다.
  - 타입스크립트 팀은 타입 기능만 발전시킨다는 명확한 원칙을 세우고 현재까지 지키고 있다.

#### 열거형(enum)

```typescript
enum Flavor {
  VANILLA = 0,
  CHOCOLATE = 1,
  STRAWBERRY = 2,
}
```

- 타입스크립트의 열거형은 다음 목록처럼 상황에 따라 다르게 동작한다.
  - 숫자 열거형에 0, 1, 2(위 예시에서) 외의 다른 숫자가 할당되면 매우 위험하다.
    - 이 방식은 원래 비트 플래그 구조를 표현하기 위해 설계되었다.
  - 상수 열거형은 보통의 열거형과 달리 런타임에 완전히 제거된다.
  - preserveConstEnums 플래그를 설정한 상태의 상수 열거형은 보통의 열거형처럼 런타임 코드에 상수 열거형 겅보를 유지한다.
  - 문자열 열거형은 런타임의 타입 안전성과 투명성을 제공한다.
- 타입스크립트의 일반적인 타입들이 할당 가능성을 체크하기 위해서 구조적 타이핑을 사용하는 반면, 문자열 열거형은 명목적 타이핑(nominally typing)을 사용한다.
- 자바스크립트와 타입스크립트에서 동작이 다르기 때문에 문자열 열거형은 사용하지 않는 것이 좋다.
  - 열거형 대신 리터럴 타입의 유니온을 사용하면 된다.
- 리터럴 타입의 유니온은 열거형만큼 안전하며 자바스크립트와 호환되는 장점이 있다.

#### 매개변수 속성

```typescript
class Person {
  constructor(public name: string) {}
}
```

- `public name`은 매개변수 속성이라고 불리며, 멤버 변수로 name을 선언한 것과 동일하게 동작하나, 다음 문제점이 존재한다.
  - 일반적으로 타입스크립트 컴파일은 타입 제거가 이루어지므로 코드가 줄어들지만, 매개변수 속성은 코드가 늘어나는 문법이다.
  - 매개변수 속성이 런타임에는 실제로 사용되지만, 타입스크립트 관점에서는 사용되지 않는 것처럼 보인다.
  - 매개변수 속성과 일반 속성을 섞어서 사용하면 클래스의 설계가 혼란스러워진다.
- 클래스에 매개변수 속성만 존재한다면 클래스 대신 인터페이스로 만들고 객체 리터럴을 사용하는 것이 좋다.

#### 네임스페이스와 트리플 슬래시 임포트

- 타입스크립트는 module 키워드와 트리플 슬래시 임포트를 사용했다.
- ECMAScript2015가 공식적으로 모듈 시스템을 도입한 이후, 타입스크립트는 충돌을 피하기 위해 module과 같은 기능을 하는 namespace 키워드를 추가했다.
- 트리플 슬래시 임포트와 module 키워드는 호환성을 위해 남아 있을 뿐이며, 이제는 import, export를 사용해야 한다.

#### 데코레이터

- 데코레이터는 클래스, 메서드, 속성에 애너테이션(annotation)을 붙이거나 기능을 추가하는 데 사용할 수 있다.

```typescript
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }

  @logged
  greet() {
    return 'Hello, ' + this.greeting;
  }
}

function logged(target: any, name: string, descriptor: PropertyDescriptor) {
  const fn = target[name];
  descriptor.value = function () {
    console.log(`Calling ${name}`);
    return fn.apply(this, arguments);
  };
}

console.log(new Greeter('Dave').greet());
// Calling greet
// Hello, Dave
```

- 데코레이터는 `tsconfig.json`에 experimentalDecorators 속성을 설정하고 사용해야 한다.
- 데코레이터는 현재까지 표준화가 완료되지 않았기 때문에, 호환성이 깨질 가능성이 있다.

#### 요약

- 일반적으로 타입스크립트 코드에서 모든 타입 정보를 제거하면 자바스크립트가 되지만, 열겨헝, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 타입 정보를 제거한다고 자바스크립트가 되지는 않다.
- 타입스크립트의 역할을 명확하게 하려면, 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 사용하지 않는 것이 좋다.

### 아이템 54. 객체를 순회하는 노하우

```typescript
const obj = {
  one: 'one',
  two: 'two',
  three: 'three',
};

for (const k in obj) {
  const v = obj[k]; // error
  // ...
}
```

- 위의 예시에서 k와 obj 객체의 키 타입이 서로 다르게 추론되어 오류가 발생한 것이다.
  - k의 타입을 구체적으로 명시하면 오류는 사라진다.

```typescript
const obj = {
  one: 'one',
  two: 'two',
  three: 'three',
};

let k: keyof typeof obj;
for (k in obj) {
  const v = obj[k]; // ok
  // ...
}
```

- interface를 사용하여 순회할 떄, 만약 인터페이스보다 확장된 타입이라면 문제가 발생할 수 있다.
  - Object.entries를 사용하면 된다.
    - 직관적이지 않지만, 복잡한 기교 없이 사용할 수 있다.
- 객체를 다룰 때는 항상 프로토타입 오염의 가능성을 염두에 두어야 하며, for-in 구문을 사용하면, 객체의 정의에 없는 속성이 등장할 수 았다.
- 객체를 순회하며 키와 값을 얻으려면 (let k: keyof T) 같은 keyof 선언이나 Object.entries를 사용하면 된다.

#### 요약

- 객체를 순회할 때, 키가 어떤 타입인지 정확히 파악하고 있다면 let k: keyof T와 for-in 루프를 사용한다. 함수의 매개변수로 쓰이는 객체에는 추가적인 키가 존재할 수 있다는 점을 명심한다.
- 객체를 순회하며 키와 값을 얻는 가장 일반적인 방법은 Object.entries를 사용하는 것이다.

### 아이템 55. DOM 계층 구조 이해하기

- 생략...

#### 요약

- 자바스크립트를 사용할 때는 신경 쓰지 않았겠지만, DOM에는 타입 계층 구조가 있다. DOM 타입은 타입스크립트에서 중요한 정보이며, 브라우저 관련 프로젝트에서 타입스크립트를 사용할 때 유용하다.
- Node, Element, HTMLElement, EventTarget 간의 차이점, 그리고 Event와 MouseEvent의 차이점을 알아야 한다.
- DOM 엘리먼트와 이벤트에는 충분히 구체적인 타입 정보를 사용하거나, 타입스크립트가 추론할 수 있도록 문맥 정보를 활용해야 한다.

### 아이템 56. 정보를 감추는 목적으로 private 사용하지 않기

- public, protected, private 같은 접근 제어자는 타입스크립트 키워드이기 때문에 컴파일 후에는 제거된다.
- 타입스크립트의 접근 제어자들은 단지 컴파일 시점에만 오류를 표시해 줄 뿐이며, 런타임에는 아무 효력이 없다.
  - 최근에는 되는 듯???...
- 자바스크립트에서 정보를 숨기기 위해 가장 효과적인 방법은 클로저를 사용하는 것이다.
  - 상황에 따라 메모리를 낭비한다.
  - 동일한 클래스로부터 생성된 인스턴스라고 하더라도 비공개 데이터에 접근하는 것은 불가능하다.
- 최근 표준화가 진행되는 방법으로 접두사 #을 붙여서 타입 체크와 런타임 모두에서 비공개로 만든다.
  - 클로저와는 달리 개별 인스턴스 끼리 접근이 가능하다.
  - 비공개 필드를 지원하지 않는 자바스크립트 버전으로 컴파일하게 되면 WeakMap을 사용한 구현으로 대체된다.
- 만약 설계 관점의 캡슐화가 아닌 보안에 대해 걱정한다면, 내장된 프로로타입과 함수에 대한 변조 같은 문제를 알고 있어야 한다.

#### 요약

- public, protected, private 접근 제어자는 타입 시스템에서만 강제될 뿐이다. 런타임에는 소용이 없으며 단언문을 통해 우회할 수 있다. 접근 제어자로 데이터를 감추려고 해서는 안 된다.
- 확실히 데이터를 감추고 싶다면 클로저를 사용해야 한다.

### 아이템 57. 소스맵을 사용하여 타입스크립트 디버깅하기

- 타입스크립트 코드를 실행한다는 것은, 타입스크립트 컴파일러가 생성한 자바스크립트 코드를 실행한다는 것이다.
  - 사실 컴파일러뿐 아니라 압축기(minifier)나 전처리기(preprocessor)처럼, 기존 코드를 다른 형태의 코드로 변환하는 도구들에도 모두 해당된다.
- 디버거는 런타임에 동작하며, 현재 동작하는 코드가 어떤 과정을 거쳐서 만들어진 것인지 알지 못한다.
- 이렇게 변환된 자바스크립트 코드는 복잡해 디버깅하기 매우 어렵다.
- 디버깅 문제를 해결하기 위해 브라우저 제조사들은 서로 협력하여 소스맵이라는 해결책을 내놓았다.
  - 소스맵은 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 매핑한다.
- 소스맵에 대해 알아야 할 사항
  - 타입스크립트와 함께 번들러나 압춫끼를 사ㅛㅇ하고 있다면, 번들러나 압축기가 각자의 소스맵을 생성하게 된다. 이상적인 디버깅 환경이 되려면 생성된 자바스크립트가 아닌 원본 타입스크립트 소스로 매핑되도록 해야 한다. 번들러가 기본적으로 타입스크립트를 지원한다면 별도 설정 없이 잘 동작해야 한다. 그렇지 않다면 번들러가 소스맵을 인식할 수 있도록 추가적인 설정이 필요하다.
  - 상용 환경에 소스맵이 유출되고 있는지 확인해야 한다. 디버거를 열지 않는 이상은 소스맵이 로드되지 않으므로, 실제 사용자에게 성능 저하는 발생하지 않다. 그러나 소스맵에 원본 코드의 인라인 복사본이 포함되어 있다면 공개해서는 안 될 내용이 들어 있을 수 있다. 저질 주석이나 내부 버그 추적을 위한 URL을 공개할 필요는 없다.

#### 요약

- 원본 코드가 아닌 변환된 자바스크립트 코드를 디버깅 하지 않는다. 소스맵을 사용해서 런타임에 타입스크립트 코드를 디버깅 한다.
- 소스맵이 최종적으로 변환된 코드에 완전히 매핑되었는지 확인한다.
- 소스맵에 원본 코드가 그대로 포홤되도록 설정되어 있을 수도 있다. 공개되지 않도록 설정을 확인한다.
