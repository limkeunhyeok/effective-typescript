# Effective Typescript

## 7장 코드를 작성하고 실행하기

### 아이템 53. 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

- 타입스크립트 초기 버전에는 독립적으로 개발한 클래스, 열거형 모듈 시스템을 포함시켰다.
  - 새로 ECMAScript에서 부족했던 점을 내장 기능으로 추가했고, 타입스크립트 초기 버전과 호환성 문제가 발생했다.
    - 타입스크립트 팀은 자바스크립트 신규 기능을 채택하고, 초기 버전과 호환성을 포기했다.
  - 타입스크립트 팀은 타입 기능만 발전시킨다는 명확한 원칙을 세우고 현재까지 지키고 있다.

#### 열거형(enum)

```typescript
enum Flavor {
  VANILLA = 0,
  CHOCOLATE = 1,
  STRAWBERRY = 2,
}
```

- 타입스크립트의 열거형은 다음 목록처럼 상황에 따라 다르게 동작한다.
  - 숫자 열거형에 0, 1, 2(위 예시에서) 외의 다른 숫자가 할당되면 매우 위험하다.
    - 이 방식은 원래 비트 플래그 구조를 표현하기 위해 설계되었다.
  - 상수 열거형은 보통의 열거형과 달리 런타임에 완전히 제거된다.
  - preserveConstEnums 플래그를 설정한 상태의 상수 열거형은 보통의 열거형처럼 런타임 코드에 상수 열거형 겅보를 유지한다.
  - 문자열 열거형은 런타임의 타입 안전성과 투명성을 제공한다.
- 타입스크립트의 일반적인 타입들이 할당 가능성을 체크하기 위해서 구조적 타이핑을 사용하는 반면, 문자열 열거형은 명목적 타이핑(nominally typing)을 사용한다.
- 자바스크립트와 타입스크립트에서 동작이 다르기 때문에 문자열 열거형은 사용하지 않는 것이 좋다.
  - 열거형 대신 리터럴 타입의 유니온을 사용하면 된다.
- 리터럴 타입의 유니온은 열거형만큼 안전하며 자바스크립트와 호환되는 장점이 있다.

#### 매개변수 속성

```typescript
class Person {
  constructor(public name: string) {}
}
```

- `public name`은 매개변수 속성이라고 불리며, 멤버 변수로 name을 선언한 것과 동일하게 동작하나, 다음 문제점이 존재한다.
  - 일반적으로 타입스크립트 컴파일은 타입 제거가 이루어지므로 코드가 줄어들지만, 매개변수 속성은 코드가 늘어나는 문법이다.
  - 매개변수 속성이 런타임에는 실제로 사용되지만, 타입스크립트 관점에서는 사용되지 않는 것처럼 보인다.
  - 매개변수 속성과 일반 속성을 섞어서 사용하면 클래스의 설계가 혼란스러워진다.
- 클래스에 매개변수 속성만 존재한다면 클래스 대신 인터페이스로 만들고 객체 리터럴을 사용하는 것이 좋다.

#### 네임스페이스와 트리플 슬래시 임포트

- 타입스크립트는 module 키워드와 트리플 슬래시 임포트를 사용했다.
- ECMAScript2015가 공식적으로 모듈 시스템을 도입한 이후, 타입스크립트는 충돌을 피하기 위해 module과 같은 기능을 하는 namespace 키워드를 추가했다.
- 트리플 슬래시 임포트와 module 키워드는 호환성을 위해 남아 있을 뿐이며, 이제는 import, export를 사용해야 한다.

#### 데코레이터

- 데코레이터는 클래스, 메서드, 속성에 애너테이션(annotation)을 붙이거나 기능을 추가하는 데 사용할 수 있다.

```typescript
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }

  @logged
  greet() {
    return 'Hello, ' + this.greeting;
  }
}

function logged(target: any, name: string, descriptor: PropertyDescriptor) {
  const fn = target[name];
  descriptor.value = function () {
    console.log(`Calling ${name}`);
    return fn.apply(this, arguments);
  };
}

console.log(new Greeter('Dave').greet());
// Calling greet
// Hello, Dave
```

- 데코레이터는 `tsconfig.json`에 experimentalDecorators 속성을 설정하고 사용해야 한다.
- 데코레이터는 현재까지 표준화가 완료되지 않았기 때문에, 호환성이 깨질 가능성이 있다.

#### 요약

- 일반적으로 타입스크립트 코드에서 모든 타입 정보를 제거하면 자바스크립트가 되지만, 열겨헝, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 타입 정보를 제거한다고 자바스크립트가 되지는 않다.
- 타입스크립트의 역할을 명확하게 하려면, 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 사용하지 않는 것이 좋다.

### 아이템 54. 객체를 순회하는 노하우

```typescript
const obj = {
  one: 'one',
  two: 'two',
  three: 'three',
};

for (const k in obj) {
  const v = obj[k]; // error
  // ...
}
```

- 위의 예시에서 k와 obj 객체의 키 타입이 서로 다르게 추론되어 오류가 발생한 것이다.
  - k의 타입을 구체적으로 명시하면 오류는 사라진다.

```typescript
const obj = {
  one: 'one',
  two: 'two',
  three: 'three',
};

let k: keyof typeof obj;
for (k in obj) {
  const v = obj[k]; // ok
  // ...
}
```

- interface를 사용하여 순회할 떄, 만약 인터페이스보다 확장된 타입이라면 문제가 발생할 수 있다.
  - Object.entries를 사용하면 된다.
    - 직관적이지 않지만, 복잡한 기교 없이 사용할 수 있다.
- 객체를 다룰 때는 항상 프로토타입 오염의 가능성을 염두에 두어야 하며, for-in 구문을 사용하면, 객체의 정의에 없는 속성이 등장할 수 았다.
- 객체를 순회하며 키와 값을 얻으려면 (let k: keyof T) 같은 keyof 선언이나 Object.entries를 사용하면 된다.

#### 요약

- 객체를 순회할 때, 키가 어떤 타입인지 정확히 파악하고 있다면 let k: keyof T와 for-in 루프를 사용한다. 함수의 매개변수로 쓰이는 객체에는 추가적인 키가 존재할 수 있다는 점을 명심한다.
- 객체를 순회하며 키와 값을 얻는 가장 일반적인 방법은 Object.entries를 사용하는 것이다.
