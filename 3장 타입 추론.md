# Effective Typescript

## 3장 타입 추론

### 아이템 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

- 타입스크립트의 많은 타입 구문은 불필요하다.
  - 값에 추가로 타입을 작성하는 것은 거추장스럽다.
- 이상적인 타입스크립트 코드는 함수/메서드 시그니처에 타입 구문을 포함하지만, 함수 내에서 생성된 지역 변수에는 타입 구문을 넣지 않는다.
  - 타입 구문을 생략하여 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 하는 것이 좋다.
- 타입이 추론될 수 있음에도 타입을 명시하면, 잉여 속성 체크가 동작하고 오타같은 오류를 잡는 데 도움이 된다.
  - 함수의 반환에도 타입을 명시하여 오류를 방지할 수 있다.
    - 반환 타입을 명시하면 함수에 대해 명확하게 알 수 있다.
    - 반환 타입을 명시하면 명명된 타입을 사용할 수 있다.
- 반환 타입을 명시하면 더욱 직관적인 표현이되고, 주석을 작성할 수 있어 자세한 설명이 가능하다.

#### 요약

- 타입스크립트가 타입을 추론할 수 있다면 타입 구문을 작성하지 않는 게 좋다.
- 이상적인 경우 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없다.
- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해 준다.

### 아이템 20. 다른 타입에는 다른 변수 사용하기

- 유니온 타입을 통해 변수의 타입을 변경할 수도 있겠지만, 차라리 별도의 변수를 도입하는 것이 낫다.
- 별도의 변수를 사용하는 것이 바람직한 이유
  - 서로 관련이 없는 두 개의 값을 분리한다.
  - 변수명을 더 구체적으로 지을 수 있다.
  - 타입 추론을 향상시키며, 타입 구문이 불필요해진다.
  - 타입이 좀 더 간결해진다.
  - let 대신 const로 변수를 선언하게 된다. const로 변수를 선언하면 코드가 간결해지고, 타입 체커가 타입을 추론하기에도 좋다.
- 타입이 바뀌는 변수는 되도록 피해야 하며, 목적이 다른 곳에는 별도의 변수명을 사용해야 한다.

#### 요약

- 변수의 값은 바뀔 수 있지만 타입은 일반적으로 바뀌지 않는다.
- 혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록 한다.

### 아이템 21. 타입 넓히기

- 런타임에 모든 변수는 유일한 값을 가진다.
  - 타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에 변수는 가능한 값들의 깁합인 타입을 갖는다.
- 상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 한다.
  - 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다.
    - 이 과정을 넓히기(widening)라고 부른다.
- 넓히기 과정을 제어할 수 있는 방법
  - const를 사용한다.
    - const를 사용하면 더 좁은 타입이 된다.
  - 명시적 타입 구문을 제공한다.
  - 타입 체커에 추가적인 문맥을 제공한다.
  - const 단언문을 사용한다.

#### 요약

- 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법을 이해해야 한다.
- 동작에 영향을 줄 수 있는 방법인 const, 타입 구문, 문맥, as const에 익숙해져야 한다.

### 아이템 22. 타입 좁히기

- 타입 좁히기는 타입스크립트가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말한다.
- 타입스크립트는 일반적으로 조건문에서 타입을 좁힌다.
- 타입을 좁히는 다른 방법은 명시적 태그를 붙이는 것이다.

```typescript
interface UploadEvent {
  type: 'upload';
  filename: string;
  contents: string;
}

interface DownloadEvent {
  type: 'download';
  filename: string;
}

type AppEvent = UploadEvent | DownloadEvent;

function handleEvent(e: AppEvent) {
  switch (e.type) {
    case 'download':
      e; // 타입 DownloadEvent
      break;
    case 'upload':
      e; // 타입 UploadEvent
      break;
  }
}
```

- 위의 패턴은 태그된 유니온(tagged union) 또는 구별된 유니온(discriminated)이라고 불리며, 타입스크립트 어디에서나 찾아볼 수 있다.
- 만약 타입스크립트가 타입을 식별하지 못한다면, 식별을 돕기 위해 커스텀 함수를 도입할 수 있다.

```typescript
function isInputElement(el: HTMLElement): el is HTMLInputElement {
  return 'value' in el;
}

function getElementContent(el: HTMLElement) {
  if (isInputElement(el)) {
    el; // 타입 HTMLInputElement
    return el.value;
  }
  el; // 타입 HTMLElement
  return el.value;
}
```

- 위의 기법을 사용자 정의 타입 가드라고 한다.
- 어떤 함수들은 타입 가드를 사용하여 배열과 객체의 타입 좁히기를 할 수 있다.

```typescript
function isDefined<T>(x: T | undefined): x is T {
  return x !== undefined;
}
const members = ['Janet', 'Michael']
  .map((who) => jackson5.find((n) => n === who))
  .filter((who) => who !== undefined);
```

- 타입스크립트에서 타입이 어떻게 좁혀지는지 이해한다면 타입 추론에 대한 개념을 잡을 수 있고, 오류 발생의 원인을 알 수 있으며, 타입 체커를 더 효율적으로 이용할 수 있다.

#### 요약

- 분기문 외에도 여러 종류의 제어 흐름을 살펴보며 타입스크립트가 타입을 좁히는 과정을 이해해야 한다.
- 태그된/구별된 유니온과 사용자 정의 타입 가드를 사용하여 타입 좁히기 과정을 원활하게 만들 수 있다.

### 아이템 23. 한꺼번에 객체 생성하기

- 객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.

```typescript
// pt 타입은 {} 값을 기준으로 추론되기 떄문에 에러남
const pt = {};
pt.x = 3; // error
pt.y = 4; // error

// Point를 기준으로 추론되며, 위와 다른 에러남
interface Point {
  x: number;
  y: number;
}
const pt = {};
pt.x = 3; // error
pt.y = 4; // error

// 정상
const pt = {
  x: 3,
  y: 4,
};

// 정상, 만약 객체를 나눠서 만들어야 한다면 타입 단언 사용
const pt = {} as Point;
pt.x = 3;
pt.y = 4;

// 정상, 객체를 한꺼번에 만드는 게 더 나음
const pt: Point = {
  x: 3,
  y: 4,
};
```

- 객체 전개 연산자를 사용하면 타입 걱정 없이 필드 단위로 객체를 생성할 수 있다.

```typescript
declare let hasMiddle: boolean;
const firstLast = { first: 'Harry', last: 'Truman' };
const president = { ...firstLast, ...(hasMiddle ? { middle: 'S' } : {}) };
```

- 위의 예시처럼 안전한 방식으로 조건부 속성을 추가하려면, 속성을 추가하지 않는 null 또는 {}으로 객체 전개를 사용한다.

#### 요약

- 속성을 제각각 추가하지 말고 한꺼번에 객체로 만들어야 한다. 안전한 타입으로 속성을 추가하려면 객체 전개를 사용한다.
- 객체에 조건부로 속성을 추가하는 방법을 익힌다.

### 아이템 24. 일관성 있는 별칭 사용하기

- 별칭의 값을 변경하면 원래 속성값에서도 변경된다.

```typescript
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if (polygon.bbox) {
    if (pt.x < box.x[0] || pt.x > box.x[1] || pt.y < box.y[0] || pt.y > box.y[1]) {
      return false
    }
  }
}
```

- 위의 코드는 동작하지만, 편집기에서 오류로 표시된다.
  - polygon.bbox를 별도의 box라는 별칭을 만들었고, 첫 번째 예제에서는 잘 동작했던 제어 흐름 분석을 방해했기 때문이다.
- 이러한 오류는 '별칭은 일관성 있게 사용한다'는 기본 원칙을 지키면 방지할 수 있다.
- 객체 비구조화를 이용하면 보다 간결한 문법으로 일관된 이름을 사용할 수 있지만 다음 두 가지를 조심해야 한다.
  - 선택적 속성일 경우 속성 체크가 더 필요하다. 따라서 타입의 경계에 null 값을 추가하는 것이 좋다.
  - 빈 배열의 경우에도 주의해야 하며, 빈 배열을 나타내는 것도 좋은 방법이다.

#### 요약

- 별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.
- 비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.
- 함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.